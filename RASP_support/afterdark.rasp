full seq display on

BOS = "^"; #beginning of sequence
EOS = "$"; #end of sequence
SEP = "|"; #separator
PAD = "_"; #padding 

_k_is_BOS = select(tokens, BOS, ==);
_k_is_EOS = select(tokens, EOS, ==);
_k_is_SEP = select(tokens, SEP, ==);
_k_is_PAD = select(tokens, PAD, ==);
_q_is_BOS = select(BOS, tokens, ==);
_q_is_EOS = select(EOS, tokens, ==);
_q_is_SEP = select(SEP, tokens, ==);
_q_is_PAD = select(PAD, tokens, ==);
_key_seq_mask = not (k_is_PAD or k_is_EOS or k_is_SEP or k_is_BOS);
_query_seq_mask = not(q_is_PAD or q_is_EOS or q_is_SEP or q_is_BOS);

# 
ignore_special_tokens = key_seq_mask and query_seq_mask;
seq_bitmask = round(aggregate(ignore_special_tokens, 1));

# IDK if it's better for the compiler to define these explicitly
# Or if I can define them in terms of each other
eq  = select(tokens, tokens, ==);
lt  = select(tokens, tokens, <);
gt  = select(tokens, tokens, >);
lte = select(tokens, tokens, <=);
gte = select(tokens, tokens, >=);

causal = select(indices, indices, <=);
diag   = select(indices, indices, ==);
before = select(indices, indices, <);
after  = select(indices, indices, >);


def index(seq, i) { 
  return aggregate(select(indices, i, ==), seq); 
}

def first(seq, char) {
  return aggregate(select_from_first(seq, char), indices);
}

def add_strnum(seq, i) {
    _seq = atoi(seq if seq_bitmask == 1 else "-9");
    _seq = itoa(_seq + i);
    _seq = _seq if seq_bitmask == 1 else seq;
    return _seq;
}

def max_val(seq){
    return index(sort(seq, -seq), 0);
}

#paper_examples.rasp#######################################

def with_bos_selector_width(s) {
	s = s or select(indices,0,==);
	return round((1/aggregate(s,indicator(indices==0))))-1;
}
def sort_bos(seq,key) {
	should_be_earlier = select(key,key,<) or (select(key,key,==) and before);
	num_before = with_bos_selector_width(should_be_earlier);
	num_before = -1 if indices==0 else num_before; 
	main_seq_grab_output = select(num_before,indices-1,==); 
	bos_grab_self = select(indices,0,==) and select(indices,indices,==);
	grab_output = main_seq_grab_output or bos_grab_self;
	return aggregate(grab_output,seq);
}
###########################################################
def max_val_bos(seq) {
    return index(sort_bos(seq, -seq), 1);
}

def select_next_identical_bos(seq) {
    _eq = select(seq, seq, ==);
	select_prev_identical = _eq and before;
	num_prev_identical = with_bos_selector_width(select_prev_identical);
	return _eq and select(num_prev_identical,num_prev_identical+1,==);
}
